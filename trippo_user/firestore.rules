rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // UNIFIED BTRIPS APP SECURITY RULES
    // Version 2.0 - Role-based access control
    // ============================================
    
    // Helper Functions
    // ============================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user owns the document
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Get user type from users collection
    function getUserType() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType;
    }
    
    // Check if user is a driver
    function isDriver() {
      return isAuthenticated() && getUserType() == 'driver';
    }
    
    // Check if user is a regular user/passenger
    function isRegularUser() {
      return isAuthenticated() && getUserType() == 'user';
    }
    
    
    // Users Collection (Central User Registry)
    // ============================================
    match /users/{userId} {
      // Anyone authenticated can read user documents (to see driver/passenger info)
      allow read: if isAuthenticated();
      
      // Users can create their own document during registration
      allow create: if isAuthenticated() && 
                      isOwner(userId) &&
                      request.resource.data.userType in ['user', 'driver'];
      
      // Users can update only their own document (phone, name, etc.)
      allow update: if isAuthenticated() && isOwner(userId);
      
      // Prevent deletion
      allow delete: if false;
    }
    
    
    // Drivers Collection (Driver-Specific Data)
    // ============================================
    match /drivers/{userId} {
      // Everyone can read driver data (for finding nearby drivers)
      allow read: if isAuthenticated();
      
      // Only drivers can create/update their own driver document
      allow create: if isAuthenticated() && 
                      isOwner(userId) && 
                      isDriver();
      
      // Drivers can update their own document (all fields)
      // Users can update ONLY the rating field (after rating a driver)
      allow update: if isAuthenticated() && (
        // Driver updating their own document
        (isOwner(userId) && isDriver()) ||
        // User updating driver's rating after a ride (ONLY rating field)
        (isRegularUser() && 
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['rating']))
      );
      
      // Prevent deletion
      allow delete: if false;
    }
    
    
    // User Profiles Collection (User-Specific Data)
    // ============================================
    match /userProfiles/{userId} {
      // Anyone authenticated can read user profiles
      allow read: if isAuthenticated();
      
      // Users can update their own profile
      allow create, update: if isAuthenticated() && 
                              isOwner(userId) && 
                              isRegularUser();
      
      // Drivers can update ONLY the rating field (when rating passengers)
      allow update: if isAuthenticated() && 
                      isDriver() &&
                      // Only allow updating rating field
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['rating']);
      
      // Prevent deletion
      allow delete: if false;
    }
    
    
    // Ride Requests Collection (Active Rides)
    // ============================================
    match /rideRequests/{requestId} {
      // Anyone authenticated can read ride requests
      allow read: if isAuthenticated();
      
      // Only regular users can create ride requests
      allow create: if isAuthenticated() && 
                      isRegularUser() &&
                      request.resource.data.userId == request.auth.uid;
      
      // Users can update their own requests
      // Drivers can accept pending rides (driverId is null)
      // Drivers can update/cancel rides assigned to them
      // Both can add ratings to completed rides
      allow update: if isAuthenticated() && (
        // User updating their own ride (including cancellation and rating)
        (resource.data.userId == request.auth.uid) ||
        // Driver accepting a pending ride (driverId is null â†’ being set)
        (isDriver() && resource.data.driverId == null && 
         request.resource.data.driverId == request.auth.uid &&
         resource.data.status == 'pending') ||
        // Driver updating their assigned ride (status, payment, cancellation, rating)
        (resource.data.driverId == request.auth.uid && isDriver()) ||
        // DELIVERY FIX: Allow driver to update if driverId matches (even without userType check)
        // This handles the case where userType might not be set yet
        (resource.data.driverId == request.auth.uid &&
         request.resource.data.keys().hasAny(['status', 'startedAt', 'deliveredAt', 'completedAt']))
      );
      
      // Users can delete their own pending requests
      allow delete: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid &&
                      resource.data.status == 'pending';
      
      // Messages Subcollection (Live Chat)
      // ============================================
      match /messages/{messageId} {
        // Both customer and driver can read messages for their ride/delivery
        allow read: if isAuthenticated() && (
          get(/databases/$(database)/documents/rideRequests/$(requestId)).data.userId == request.auth.uid ||
          get(/databases/$(database)/documents/rideRequests/$(requestId)).data.driverId == request.auth.uid
        );
        
        // Both can create messages ONLY when ride is active (accepted or ongoing)
        allow create: if isAuthenticated() && 
          (get(/databases/$(database)/documents/rideRequests/$(requestId)).data.userId == request.auth.uid ||
           get(/databases/$(database)/documents/rideRequests/$(requestId)).data.driverId == request.auth.uid) &&
          (get(/databases/$(database)/documents/rideRequests/$(requestId)).data.status in ['accepted', 'ongoing']) &&
          request.resource.data.senderId == request.auth.uid;
        
        // Can update own messages (e.g., mark as read)
        allow update: if isAuthenticated() && resource.data.senderId == request.auth.uid;
        
        // No deletion - keep chat history
        allow delete: if false;
      }
    }
    
    
    // Ride History Collection (Completed Rides)
    // ============================================
    match /rideHistory/{rideId} {
      // Users and drivers can read rides they participated in
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.driverId == request.auth.uid
      );
      
      // Allow anyone to create history if they're the driver or user
      // RELAXED for deliveries - don't require strict userType check
      allow create: if isAuthenticated() && (
        (request.resource.data.driverId == request.auth.uid) ||
        (request.resource.data.userId == request.auth.uid)
      );
      
      // Users can update to add their rating and feedback
      // Drivers can update to add their rating and feedback, and payment status
      allow update: if isAuthenticated() && (
        // User rating driver (can update userRating and/or userFeedback only)
        (resource.data.userId == request.auth.uid && 
         isRegularUser() &&
         (request.resource.data.diff(resource.data).affectedKeys().hasAny(['userRating', 'userFeedback']) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['userRating', 'userFeedback']))) ||
        // Driver rating user (can update driverRating and/or driverFeedback only)
        (resource.data.driverId == request.auth.uid && 
         isDriver() &&
         (request.resource.data.diff(resource.data).affectedKeys().hasAny(['driverRating', 'driverFeedback']) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['driverRating', 'driverFeedback']))) ||
        // Driver updating payment status (for cash payments)
        (resource.data.driverId == request.auth.uid && 
         isDriver() &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['paymentStatus', 'paymentProcessedAt']))
      );
      
      // Prevent deletion
      allow delete: if false;
    }
    
    
    // Ratings Collection (Dedicated Rating Records)
    // ============================================
    match /ratings/{ratingId} {
      // Anyone authenticated can read ratings
      allow read: if isAuthenticated();
      
      // Only the person who gave the rating can create it
      // Must be the rater and have correct role
      allow create: if isAuthenticated() && 
                      request.resource.data.ratedBy == request.auth.uid &&
                      // Must have required fields
                      request.resource.data.keys().hasAll([
                        'ratingType', 'rideId', 'ratedBy', 'ratedUser', 
                        'rating', 'createdAt'
                      ]) &&
                      // Rating must be between 1 and 5
                      request.resource.data.rating >= 1 &&
                      request.resource.data.rating <= 5 &&
                      // Must be either driver rating user OR user rating driver
                      (
                        (request.resource.data.ratingType == 'driver-to-user' && isDriver()) ||
                        (request.resource.data.ratingType == 'user-to-driver' && isRegularUser())
                      );
      
      // Ratings are immutable (can't be updated after creation)
      allow update: if false;
      
      // Ratings cannot be deleted (permanent record)
      allow delete: if false;
    }
    
    
    // Preset Locations Collection (Popular Destinations)
    // ============================================
    match /presetLocations/{locationId} {
      // Anyone (including unauthenticated) can read active preset locations
      // This allows the app to show locations before login
      allow read: if true;
      
      // Only authenticated users can write (for now - should be admin only in production)
      // TODO: Restrict to admin role only
      allow write: if isAuthenticated();
      
      // Production rule (uncomment when admin role is implemented):
      // allow write: if isAuthenticated() && getUserType() == 'admin';
    }
    
    
    // Preset Locations Collection (Airports, Popular Destinations)
    // ============================================
    match /presetLocations/{locationId} {
      // Anyone authenticated can read preset locations
      allow read: if isAuthenticated();
      
      // Only admins can create/update/delete (TODO: add admin role check)
      allow create, update, delete: if false; // Restrict to admin only
    }
    
    
    // Stripe Collections (Payment Processing)
    // ============================================
    
    // Stripe Customers Collection
    // Stores Stripe customer IDs and payment methods
    match /stripeCustomers/{userId} {
      // Users can only read their own Stripe customer data
      allow read: if isAuthenticated() && isOwner(userId);
      
      // Users can create their own customer record (during first payment setup)
      allow create: if isAuthenticated() && 
                      isOwner(userId) &&
                      request.resource.data.userId == userId;
      
      // Users can update their own payment methods and billing address
      // But cannot change stripeCustomerId (set once, immutable)
      allow update: if isAuthenticated() && 
                      isOwner(userId) &&
                      request.resource.data.stripeCustomerId == resource.data.stripeCustomerId &&
                      request.resource.data.userId == userId;
      
      // Users cannot delete their Stripe customer record
      // (Deactivation should be handled by setting isActive = false)
      allow delete: if false;
      
      // Admin access (uncomment when admin role is implemented)
      // allow read: if isAuthenticated() && (isOwner(userId) || getUserType() == 'admin');
      // allow write: if isAuthenticated() && (isOwner(userId) || getUserType() == 'admin');
    }
    
    // Stripe Payment Intents Collection
    // Stores payment intent records for each transaction
    match /stripePaymentIntents/{intentId} {
      // Users can read their own payment intents
      allow read: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
      
      // Payment intents are created by Cloud Functions only
      allow create: if false;
      
      // Payment intents can be updated by Cloud Functions only (status changes)
      allow update: if false;
      
      // Payment intents are immutable (audit trail)
      allow delete: if false;
    }
    
    // Stripe Transactions Collection
    // Stores completed transaction records (ride payments, refunds, etc.)
    match /stripeTransactions/{transactionId} {
      // Users can read their own transactions (as user or driver)
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid ||
                     resource.data.driverId == request.auth.uid);
      
      // Transactions are created by Cloud Functions only
      allow create: if false;
      
      // Transactions are immutable (audit trail)
      allow update, delete: if false;
    }
    
    // Admin Invoices Collection
    // Stores manual invoices created by admins
    match /adminInvoices/{invoiceId} {
      // Check if user is an admin
      function isAdmin() {
        return isAuthenticated() && getUserType() == 'admin';
      }
      
      // Admins can read all invoices, users can read their own invoices
      allow read: if isAuthenticated() && (
        isAdmin() ||                                    // Admins see all
        resource.data.userId == request.auth.uid       // Users see their own
      );
      
      // Only cloud functions can create invoices (not even admins directly)
      allow create: if false;
      
      // Invoices are immutable (audit trail)
      allow update, delete: if false;
    }
    
    
    // Legacy Collections (Backward Compatibility)
    // ============================================
    
    // Favorite Places Collection
    // ============================================
    match /favoritePlaces/{favoriteId} {
      // Users can only read their own favorites
      allow read: if isAuthenticated() && 
                   resource.data.userId == request.auth.uid;
      
      // Users can create favorites for themselves
      allow create: if isAuthenticated() && 
                    request.resource.data.userId == request.auth.uid;
      
      // Users can update their own favorites (nickname, category, useCount)
      allow update: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
      
      // Users can delete their own favorites
      allow delete: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
    }
    
    // Old driver collection format - still allow reads
    match /Drivers/{driverEmail} {
      allow read: if isAuthenticated();
      allow write: if false; // Deprecated, use drivers/ collection
    }
    
    // Old user ride history by email
    match /{userEmail}/{rideId} {
      // Allow users to read their own ride history
      allow read: if isAuthenticated() && 
                    request.auth.token.email == userEmail;
      allow write: if false; // Deprecated, use rideHistory/ collection
    }
  }
}
